<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/MeliProductApp.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/MeliProductApp.kt" />
              <option name="originalContent" value="package com.example.meliproducts&#10;&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.material3.TopAppBarDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import com.example.meliproducts.ui.detail.ProductDetailScreen&#10;import com.example.meliproducts.ui.detail.ProductDetailViewModel&#10;import com.example.meliproducts.ui.search.SearchScreen&#10;import com.example.meliproducts.ui.search.SearchViewModel&#10;import com.example.meliproducts.ui.searchresult.SearchResultScreen&#10;&#10;const val ROUTE_SEARCH = &quot;search&quot;&#10;const val ROUTE_RESULTS = &quot;results&quot;&#10;const val ROUTE_DETAILS = &quot;product_details&quot;&#10;&#10;@Composable&#10;fun MeliProductApp(&#10;    navController: NavHostController = rememberNavController(),&#10;) {&#10;    val backStackEntry = navController.currentBackStackEntryAsState()&#10;    val currentRoute = backStackEntry.value?.destination?.route ?: ROUTE_SEARCH&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            CustomAppBar(&#10;                currentScreen = currentRoute,&#10;                canNavigateBack = navController.previousBackStackEntry != null,&#10;                navigateUp = { navController.navigateUp() }&#10;            )&#10;        },&#10;        modifier = Modifier.fillMaxSize()&#10;    ) { innerPadding -&gt;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = ROUTE_SEARCH,&#10;            modifier = Modifier.padding(innerPadding)&#10;        ) {&#10;            composable(route = ROUTE_SEARCH) {&#10;                val searchViewModel: SearchViewModel = hiltViewModel()&#10;                SearchScreen(&#10;                    onSearch = { query -&gt;&#10;                        navController.navigate(&quot;$ROUTE_RESULTS/$query&quot;)&#10;                    },&#10;                )&#10;            }&#10;            composable(&#10;                route = &quot;$ROUTE_RESULTS/{searchTerm}&quot;,&#10;                arguments = listOf(&#10;                    navArgument(&quot;searchTerm&quot;) { type = NavType.StringType }&#10;                )&#10;            ) { backStackEntry -&gt;&#10;                val searchTerm = backStackEntry.arguments?.getString(&quot;searchTerm&quot;) ?: &quot;&quot;&#10;                SearchResultScreen(&#10;                    searchTerm = searchTerm,&#10;                    onProductClick = { productId, categoryId -&gt;&#10;                        navController.navigate(&quot;$ROUTE_DETAILS/$productId/$categoryId&quot;)&#10;                    }&#10;                )&#10;            }&#10;            composable(&#10;                route = &quot;$ROUTE_DETAILS/{productId}/{categoryId}&quot;,&#10;                arguments = listOf(&#10;                    navArgument(&quot;productId&quot;) { type = NavType.StringType },&#10;                    navArgument(&quot;categoryId&quot;) { type = NavType.StringType }&#10;                )&#10;            ) { backStackEntry -&gt;&#10;                val productDetailViewModel: ProductDetailViewModel = hiltViewModel()&#10;                val productId = backStackEntry.arguments?.getString(&quot;productId&quot;) ?: &quot;&quot;&#10;                val categoryId = backStackEntry.arguments?.getString(&quot;categoryId&quot;) ?: &quot;&quot;&#10;                LaunchedEffect(productId, categoryId) {&#10;                    if (productId.isNotBlank() &amp;&amp; categoryId.isNotBlank()) {&#10;                        productDetailViewModel.loadProduct(productId, categoryId)&#10;                    }&#10;                }&#10;                ProductDetailScreen(&#10;                    uiState = productDetailViewModel.uiState.collectAsState(),&#10;                    onBack = { navController.navigateUp() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun CustomAppBar(&#10;    currentScreen: String,&#10;    canNavigateBack: Boolean,&#10;    navigateUp: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    TopAppBar(&#10;        title = { Text(currentScreen) },&#10;        colors = TopAppBarDefaults.mediumTopAppBarColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer&#10;        ),&#10;        modifier = modifier,&#10;        navigationIcon = {&#10;            if (canNavigateBack) {&#10;                IconButton(onClick = navigateUp) {&#10;                    Icon(&#10;                        imageVector = Icons.Filled.ArrowBack,&#10;                        contentDescription = stringResource(R.string.back_button)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.meliproducts&#10;&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.stringResource&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.NavType&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.navigation.navArgument&#10;import com.example.meliproducts.ui.detail.ProductDetailScreen&#10;import com.example.meliproducts.ui.detail.ProductDetailViewModel&#10;import com.example.meliproducts.ui.search.SearchScreen&#10;import com.example.meliproducts.ui.search.SearchViewModel&#10;import com.example.meliproducts.ui.searchresult.SearchResultScreen&#10;&#10;const val ROUTE_SEARCH = &quot;search&quot;&#10;const val ROUTE_RESULTS = &quot;results&quot;&#10;const val ROUTE_DETAILS = &quot;product_details&quot;&#10;&#10;@Composable&#10;fun MeliProductApp(&#10;    navController: NavHostController = rememberNavController(),&#10;) {&#10;    val backStackEntry = navController.currentBackStackEntryAsState()&#10;    val currentRoute = backStackEntry.value?.destination?.route ?: ROUTE_SEARCH&#10;&#10;    NavHost(&#10;        navController = navController,&#10;        startDestination = ROUTE_SEARCH,&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        composable(route = ROUTE_SEARCH) {&#10;            val searchViewModel: SearchViewModel = hiltViewModel()&#10;            SearchScreen(&#10;                onSearch = { query -&gt;&#10;                    navController.navigate(&quot;$ROUTE_RESULTS/$query&quot;)&#10;                },&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;$ROUTE_RESULTS/{searchTerm}&quot;,&#10;            arguments = listOf(&#10;                navArgument(&quot;searchTerm&quot;) { type = NavType.StringType }&#10;            )&#10;        ) { backStackEntry -&gt;&#10;            val searchTerm = backStackEntry.arguments?.getString(&quot;searchTerm&quot;) ?: &quot;&quot;&#10;            SearchResultScreen(&#10;                searchTerm = searchTerm,&#10;                onProductClick = { productId, categoryId -&gt;&#10;                    navController.navigate(&quot;$ROUTE_DETAILS/$productId/$categoryId&quot;)&#10;                }&#10;            )&#10;        }&#10;        composable(&#10;            route = &quot;$ROUTE_DETAILS/{productId}/{categoryId}&quot;,&#10;            arguments = listOf(&#10;                navArgument(&quot;productId&quot;) { type = NavType.StringType },&#10;                navArgument(&quot;categoryId&quot;) { type = NavType.StringType }&#10;            )&#10;        ) { backStackEntry -&gt;&#10;            val productDetailViewModel: ProductDetailViewModel = hiltViewModel()&#10;            val productId = backStackEntry.arguments?.getString(&quot;productId&quot;) ?: &quot;&quot;&#10;            val categoryId = backStackEntry.arguments?.getString(&quot;categoryId&quot;) ?: &quot;&quot;&#10;            LaunchedEffect(productId, categoryId) {&#10;                if (productId.isNotBlank() &amp;&amp; categoryId.isNotBlank()) {&#10;                    productDetailViewModel.loadProduct(productId, categoryId)&#10;                }&#10;            }&#10;            ProductDetailScreen(&#10;                uiState = productDetailViewModel.uiState.collectAsState(),&#10;                onBack = { navController.navigateUp() }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/MeliProductsApp.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/MeliProductsApp.kt" />
              <option name="updatedContent" value="package com.example.meliproducts&#10;&#10;import android.app.Application&#10;import dagger.hilt.android.HiltAndroidApp&#10;&#10;@HiltAndroidApp&#10;class MeliProductsApp : Application()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/data/util/Result.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/data/util/Result.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.data.util&#10;&#10;/**&#10; * Representa o resultado de uma operação que pode ter sucesso ou falha.&#10; */&#10;sealed class Result&lt;out T&gt; {&#10;    data class Success&lt;out T&gt;(val data: T) : Result&lt;T&gt;()&#10;    data class Error(val exception: Throwable) : Result&lt;Nothing&gt;()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/di/AppModule.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.di&#10;&#10;import android.content.Context&#10;import com.example.meliproducts.data.repository.LocalProductRepository&#10;import com.example.meliproducts.data.repository.ProductRepository&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;    @Provides&#10;    @Singleton&#10;    fun provideProductRepository(&#10;        @ApplicationContext context: Context&#10;    ): ProductRepository = LocalProductRepository(context)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/components/LoadingErrorEmpty.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/components/LoadingErrorEmpty.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.presentation.components&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;&#10;/**&#10; * Componente reutilizável para exibir loading, erro ou estado vazio.&#10; */&#10;@Composable&#10;fun LoadingView() {&#10;    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;        CircularProgressIndicator()&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ErrorView(message: String) {&#10;    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;        Text(&#10;            text = message,&#10;            color = MaterialTheme.colorScheme.error,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EmptyView(message: String = &quot;Nenhum resultado encontrado&quot;) {&#10;    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;        Text(&#10;            text = message,&#10;            style = MaterialTheme.typography.bodyLarge,&#10;            textAlign = TextAlign.Center&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/detail/ProductDetailScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/detail/ProductDetailScreen.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.presentation.detail&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import coil.compose.AsyncImage&#10;import com.example.meliproducts.presentation.components.ErrorView&#10;import com.example.meliproducts.presentation.components.LoadingView&#10;import com.example.meliproducts.presentation.components.EmptyView&#10;&#10;/**&#10; * Tela de detalhe do produto.&#10; * Exibe detalhes, descrição e categoria.&#10; */&#10;@Composable&#10;fun ProductDetailScreen(&#10;    uiState: androidx.compose.runtime.State&lt;ProductDetailUiState&gt;,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Detalhe do Produto&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, contentDescription = &quot;Voltar&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { padding -&gt;&#10;        Box(modifier = Modifier.padding(padding).fillMaxSize()) {&#10;            when (val state = uiState.value) {&#10;                is ProductDetailUiState.Loading -&gt; LoadingView()&#10;                is ProductDetailUiState.Error -&gt; ErrorView(state.message)&#10;                is ProductDetailUiState.Success -&gt; {&#10;                    val detail = state.detail&#10;                    LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                        item {&#10;                            AsyncImage(&#10;                                model = detail.thumbnail,&#10;                                contentDescription = detail.title,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .height(220.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Text(&#10;                                detail.title,&#10;                                style = MaterialTheme.typography.titleLarge,&#10;                                fontWeight = FontWeight.Bold,&#10;                                modifier = Modifier.padding(horizontal = 16.dp)&#10;                            )&#10;                            Text(&#10;                                &quot;R$ %.2f&quot;.format(detail.price),&#10;                                style = MaterialTheme.typography.headlineSmall,&#10;                                color = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.padding(horizontal = 16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            Text(&#10;                                &quot;Atributos:&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                modifier = Modifier.padding(horizontal = 16.dp)&#10;                            )&#10;                        }&#10;                        items(detail.attributes.size) { idx -&gt;&#10;                            val attr = detail.attributes[idx]&#10;                            Text(&#10;                                &quot;${attr.name}: ${attr.value_name ?: &quot;-&quot;}&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                modifier = Modifier.padding(horizontal = 24.dp, vertical = 2.dp)&#10;                            )&#10;                        }&#10;                        item {&#10;                            Spacer(modifier = Modifier.height(12.dp))&#10;                            Text(&#10;                                &quot;Descrição:&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                modifier = Modifier.padding(horizontal = 16.dp)&#10;                            )&#10;                            Text(&#10;                                state.description?.plain_text ?: &quot;Sem descrição&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 4.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.height(12.dp))&#10;                            Text(&#10;                                &quot;Categoria:&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                modifier = Modifier.padding(horizontal = 16.dp)&#10;                            )&#10;                            Text(&#10;                                state.category?.path_from_root?.joinToString(&quot; &gt; &quot;) { it.name } ?: &quot;-&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                modifier = Modifier.padding(horizontal = 16.dp, vertical = 4.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                ProductDetailUiState.Idle -&gt; EmptyView(&quot;Selecione um produto&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/detail/ProductDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/detail/ProductDetailViewModel.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.presentation.detail&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.meliproducts.data.model.Category&#10;import com.example.meliproducts.data.model.ProductDescription&#10;import com.example.meliproducts.data.model.ProductDetail&#10;import com.example.meliproducts.data.repository.ProductRepository&#10;import com.example.meliproducts.data.util.Result&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Estados possíveis da tela de detalhe do produto.&#10; */&#10;sealed class ProductDetailUiState {&#10;    object Idle : ProductDetailUiState()&#10;    object Loading : ProductDetailUiState()&#10;    data class Success(&#10;        val detail: ProductDetail,&#10;        val description: ProductDescription?,&#10;        val category: Category?&#10;    ) : ProductDetailUiState()&#10;    data class Error(val message: String) : ProductDetailUiState()&#10;}&#10;&#10;/**&#10; * ViewModel da tela de detalhe do produto.&#10; * Carrega detalhes, descrição e categoria do produto.&#10; */&#10;class ProductDetailViewModel(&#10;    private val repository: ProductRepository&#10;) : ViewModel() {&#10;    private val _uiState = MutableStateFlow&lt;ProductDetailUiState&gt;(ProductDetailUiState.Idle)&#10;    val uiState: StateFlow&lt;ProductDetailUiState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Carrega os dados completos do produto (detalhe, descrição, categoria).&#10;     */&#10;    fun loadProduct(id: String, categoryId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = ProductDetailUiState.Loading&#10;            val detailResult = repository.getProductDetail(id)&#10;            if (detailResult is Result.Success) {&#10;                val detail = detailResult.data&#10;                val descResult = repository.getProductDescription(id)&#10;                val catResult = repository.getProductCategory(categoryId)&#10;                val desc = (descResult as? Result.Success)?.data&#10;                val cat = (catResult as? Result.Success)?.data&#10;                _uiState.value = ProductDetailUiState.Success(detail, desc, cat)&#10;            } else if (detailResult is Result.Error) {&#10;                _uiState.value = ProductDetailUiState.Error(detailResult.exception.message ?: &quot;Erro ao carregar produto&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/search/SearchScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/search/SearchScreen.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.presentation.search&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalFocusManager&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.example.meliproducts.presentation.components.*&#10;import com.example.meliproducts.presentation.search.components.ProductListItem&#10;import kotlinx.coroutines.flow.StateFlow&#10;&#10;/**&#10; * Tela de pesquisa e resultados.&#10; * Observa o estado do ViewModel e exibe loading, erro ou lista de produtos.&#10; */&#10;@Composable&#10;fun SearchScreen(&#10;    uiState: StateFlow&lt;SearchUiState&gt;,&#10;    onSearch: (String) -&gt; Unit,&#10;    onProductClick: (productId: String, categoryId: String) -&gt; Unit&#10;) {&#10;    val state by uiState.collectAsStateWithLifecycle()&#10;    var query by rememberSaveable { mutableStateOf(&quot;&quot;) }&#10;    val focusManager = LocalFocusManager.current&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(title = { Text(&quot;Buscar Produtos&quot;) })&#10;        }&#10;    ) { padding -&gt;&#10;        Column(modifier = Modifier&#10;            .padding(padding)&#10;            .fillMaxSize()&#10;        ) {&#10;            OutlinedTextField(&#10;                value = query,&#10;                onValueChange = { query = it },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                label = { Text(&quot;Buscar...&quot;) },&#10;                singleLine = true,&#10;                keyboardOptions = KeyboardOptions.Default.copy(imeAction = ImeAction.Search),&#10;                keyboardActions = KeyboardActions(&#10;                    onSearch = {&#10;                        onSearch(query)&#10;                        focusManager.clearFocus()&#10;                    }&#10;                )&#10;            )&#10;            Button(&#10;                onClick = {&#10;                    onSearch(query)&#10;                    focusManager.clearFocus()&#10;                },&#10;                modifier = Modifier&#10;                    .padding(horizontal = 16.dp)&#10;                    .fillMaxWidth()&#10;            ) {&#10;                Text(&quot;Buscar&quot;)&#10;            }&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            when (state) {&#10;                is SearchUiState.Loading -&gt; LoadingView()&#10;                is SearchUiState.Error -&gt; ErrorView((state as SearchUiState.Error).message)&#10;                is SearchUiState.Success -&gt; {&#10;                    val products = (state as SearchUiState.Success).products&#10;                    if (products.isEmpty()) {&#10;                        EmptyView()&#10;                    } else {&#10;                        LazyColumn(modifier = Modifier.fillMaxSize()) {&#10;                            items(products.size) { idx -&gt;&#10;                                val product = products[idx]&#10;                                ProductListItem(&#10;                                    product = product,&#10;                                    onClick = { onProductClick(product.id, product.category_id) }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                SearchUiState.Idle -&gt; {}&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/search/SearchViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/search/SearchViewModel.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.presentation.search&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.meliproducts.data.model.Product&#10;import com.example.meliproducts.data.repository.ProductRepository&#10;import com.example.meliproducts.data.util.Result&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Estados possíveis da tela de busca/resultados.&#10; */&#10;sealed class SearchUiState {&#10;    object Idle : SearchUiState()&#10;    object Loading : SearchUiState()&#10;    data class Success(val products: List&lt;Product&gt;) : SearchUiState()&#10;    data class Error(val message: String) : SearchUiState()&#10;}&#10;&#10;/**&#10; * ViewModel da tela de busca/resultados.&#10; * Consome o ProductRepository e expõe o estado da tela via StateFlow.&#10; */&#10;class SearchViewModel(&#10;    private val repository: ProductRepository&#10;) : ViewModel() {&#10;    private val _uiState = MutableStateFlow&lt;SearchUiState&gt;(SearchUiState.Idle)&#10;    val uiState: StateFlow&lt;SearchUiState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Realiza a busca de produtos pelo termo informado.&#10;     */&#10;    fun search(query: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = SearchUiState.Loading&#10;            when (val result = repository.searchProducts(query)) {&#10;                is Result.Success -&gt; _uiState.value = SearchUiState.Success(result.data)&#10;                is Result.Error -&gt; _uiState.value = SearchUiState.Error(result.exception.message ?: &quot;Erro desconhecido&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/search/components/ProductListItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/presentation/search/components/ProductListItem.kt" />
              <option name="updatedContent" value="package com.example.meliproducts.presentation.search.components&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import com.example.meliproducts.data.model.Product&#10;&#10;/**&#10; * Item de produto para lista de resultados.&#10; */&#10;@Composable&#10;fun ProductListItem(&#10;    product: Product,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp, horizontal = 8.dp)&#10;            .clickable { onClick() }&#10;    ) {&#10;        Row(&#10;            modifier = Modifier.padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            AsyncImage(&#10;                model = product.thumbnail,&#10;                contentDescription = product.title,&#10;                modifier = Modifier.size(72.dp),&#10;                contentScale = ContentScale.Crop&#10;            )&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(product.title, style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)&#10;                Text(&quot;R$ %.2f&quot;.format(product.price), style = MaterialTheme.typography.bodyLarge)&#10;                product.official_store_name?.let {&#10;                    Text(it, style = MaterialTheme.typography.labelMedium, color = MaterialTheme.colorScheme.primary)&#10;                }&#10;                Text(product.condition, style = MaterialTheme.typography.labelSmall)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/ui/detail/ProductDetailViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/meliproducts/ui/detail/ProductDetailViewModel.kt" />
              <option name="originalContent" value="package com.example.meliproducts.ui.detail&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.meliproducts.data.model.Category&#10;import com.example.meliproducts.data.model.ProductDescription&#10;import com.example.meliproducts.data.model.ProductDetail&#10;import com.example.meliproducts.data.repository.ProductRepository&#10;import com.example.meliproducts.data.util.Result&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Estados possíveis da tela de detalhe do produto.&#10; */&#10;sealed class ProductDetailUiState {&#10;    object Idle : ProductDetailUiState()&#10;    object Loading : ProductDetailUiState()&#10;    data class Success(&#10;        val detail: ProductDetail,&#10;        val description: ProductDescription?,&#10;        val category: Category?&#10;    ) : ProductDetailUiState()&#10;&#10;    data class Error(val message: String) : ProductDetailUiState()&#10;}&#10;&#10;/**&#10; * ViewModel da tela de detalhe do produto.&#10; * Carrega detalhes, descrição e categoria do produto.&#10; */&#10;class ProductDetailViewModel(&#10;    private val repository: ProductRepository&#10;) : ViewModel() {&#10;    private val _uiState = MutableStateFlow&lt;ProductDetailUiState&gt;(ProductDetailUiState.Idle)&#10;    val uiState: StateFlow&lt;ProductDetailUiState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Carrega os dados completos do produto (detalhe, descrição, categoria).&#10;     */&#10;    fun loadProduct(id: String, categoryId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = ProductDetailUiState.Loading&#10;            val detailResult = repository.getProductDetail(id)&#10;            if (detailResult is Result.Success) {&#10;                val detail = detailResult.data&#10;                val descResult = repository.getProductDescription(id)&#10;                val catResult = repository.getProductCategory(categoryId)&#10;                val desc = (descResult as? Result.Success)?.data&#10;                val cat = (catResult as? Result.Success)?.data&#10;                _uiState.value = ProductDetailUiState.Success(detail, desc, cat)&#10;            } else if (detailResult is Result.Error) {&#10;                _uiState.value = ProductDetailUiState.Error(&#10;                    detailResult.exception.message ?: &quot;Erro ao carregar produto&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.meliproducts.ui.detail&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.meliproducts.data.model.Category&#10;import com.example.meliproducts.data.model.ProductDescription&#10;import com.example.meliproducts.data.model.ProductDetail&#10;import com.example.meliproducts.data.repository.ProductRepository&#10;import com.example.meliproducts.data.util.Result&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Estados possíveis da tela de detalhe do produto.&#10; */&#10;sealed class ProductDetailUiState {&#10;    object Idle : ProductDetailUiState()&#10;    object Loading : ProductDetailUiState()&#10;    data class Success(&#10;        val detail: ProductDetail,&#10;        val description: ProductDescription?,&#10;        val category: Category?&#10;    ) : ProductDetailUiState()&#10;&#10;    data class Error(val message: String) : ProductDetailUiState()&#10;}&#10;&#10;/**&#10; * ViewModel da tela de detalhe do produto.&#10; * Carrega detalhes, descrição e categoria do produto.&#10; */&#10;@HiltViewModel&#10;class ProductDetailViewModel @Inject constructor(&#10;    private val repository: ProductRepository&#10;) : ViewModel() {&#10;    private val _uiState = MutableStateFlow&lt;ProductDetailUiState&gt;(ProductDetailUiState.Idle)&#10;    val uiState: StateFlow&lt;ProductDetailUiState&gt; = _uiState.asStateFlow()&#10;&#10;    /**&#10;     * Carrega os dados completos do produto (detalhe, descrição, categoria).&#10;     */&#10;    fun loadProduct(id: String, categoryId: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = ProductDetailUiState.Loading&#10;            val detailResult = repository.getProductDetail(id)&#10;            if (detailResult is Result.Success) {&#10;                val detail = detailResult.data&#10;                val descResult = repository.getProductDescription(id)&#10;                val catResult = repository.getProductCategory(categoryId)&#10;                val desc = (descResult as? Result.Success)?.data&#10;                val cat = (catResult as? Result.Success)?.data&#10;                _uiState.value = ProductDetailUiState.Success(detail, desc, cat)&#10;            } else if (detailResult is Result.Error) {&#10;                _uiState.value = ProductDetailUiState.Error(&#10;                    detailResult.exception.message ?: &quot;Erro ao carregar produto&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/test/java/com/example/meliproducts/ui/productdetail/ProductDetailViewModelTest.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/test/java/com/example/meliproducts/ui/productdetail/ProductDetailViewModelTest.kt" />
              <option name="originalContent" value="package com.example.meliproducts.ui.productdetail&#10;&#10;import com.example.meliproducts.data.model.Category&#10;import com.example.meliproducts.data.model.ProductDescription&#10;import com.example.meliproducts.data.model.ProductDetail&#10;import com.example.meliproducts.data.repository.ProductRepository&#10;import com.example.meliproducts.data.util.Result&#10;import io.mockk.coEvery&#10;import io.mockk.mockk&#10;import kotlinx.coroutines.ExperimentalCoroutinesApi&#10;import kotlinx.coroutines.test.advanceUntilIdle&#10;import kotlinx.coroutines.test.runTest&#10;import org.junit.Assert.assertTrue&#10;import org.junit.Test&#10;&#10;@OptIn(ExperimentalCoroutinesApi::class)&#10;class ProductDetailViewModelTest {&#10;&#10;    @Test&#10;    fun productDetailViewModel_LoadProductSuccess_UpdatesUiStateToSuccess() = runTest {&#10;        val repository = mockk&lt;ProductRepository&gt;()&#10;        val detail = ProductDetail(&#10;            id = &quot;id&quot;,&#10;            title = &quot;Product&quot;,&#10;            categoryId = &quot;cat&quot;,&#10;            price = 100.0,&#10;            basePrice = 100.0,&#10;            originalPrice = null,&#10;            currencyId = &quot;BRL&quot;,&#10;            thumbnail = &quot;url&quot;,&#10;            pictures = emptyList(),&#10;            attributes = emptyList(),&#10;            shipping = mockk(),&#10;            warranty = null&#10;        )&#10;        val description = ProductDescription(&#10;            text = &quot;Description of the product&quot;,&#10;            plainText = &quot;Plain description&quot;&#10;        )&#10;        val category = Category(&#10;            id = &quot;cat&quot;,&#10;            name = &quot;Category Name&quot;,&#10;            picture = &quot;category_picture_url&quot;,&#10;            pathFromRoot = listOf(),&#10;        )&#10;&#10;        coEvery { repository.getProductDetail(&quot;id&quot;) } returns Result.Success(detail)&#10;        coEvery { repository.getProductDescription(&quot;id&quot;) } returns Result.Success(description)&#10;        coEvery { repository.getProductCategory(&quot;cat&quot;) } returns Result.Success(category)&#10;&#10;        val viewModel = ProductDetailViewModel(repository)&#10;        viewModel.loadProduct(&quot;id&quot;, &quot;cat&quot;)&#10;        advanceUntilIdle()&#10;&#10;        assertTrue(viewModel.uiState.value is ProductDetailUiState.Success)&#10;    }&#10;&#10;    @Test&#10;    fun productDetailViewModel_LoadProductError_UpdatesUiStateToError() = runTest {&#10;        val repository = mockk&lt;ProductRepository&gt;()&#10;        coEvery { repository.getProductDetail(&quot;id&quot;) } returns Result.Error(Exception(&quot;Not found&quot;))&#10;&#10;        val viewModel = ProductDetailViewModel(repository)&#10;        viewModel.loadProduct(&quot;id&quot;, &quot;cat&quot;)&#10;        advanceUntilIdle()&#10;&#10;        assertTrue(viewModel.uiState.value is ProductDetailUiState.Error)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.meliproducts.ui.productdetail&#10;&#10;import com.example.meliproducts.data.model.Category&#10;import com.example.meliproducts.data.model.ProductDescription&#10;import com.example.meliproducts.data.model.ProductDetail&#10;import com.example.meliproducts.data.repository.ProductRepository&#10;import com.example.meliproducts.data.util.Result&#10;import io.mockk.coEvery&#10;import io.mockk.mockk&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.ExperimentalCoroutinesApi&#10;import kotlinx.coroutines.test.UnconfinedTestDispatcher&#10;import kotlinx.coroutines.test.advanceUntilIdle&#10;import kotlinx.coroutines.test.resetMain&#10;import kotlinx.coroutines.test.runTest&#10;import kotlinx.coroutines.test.setMain&#10;import org.junit.After&#10;import org.junit.Assert.assertTrue&#10;import org.junit.Before&#10;import org.junit.Test&#10;&#10;@OptIn(ExperimentalCoroutinesApi::class)&#10;class ProductDetailViewModelTest {&#10;    private val testDispatcher = UnconfinedTestDispatcher()&#10;&#10;    @Before&#10;    fun setup() {&#10;        Dispatchers.setMain(testDispatcher)&#10;    }&#10;&#10;    @After&#10;    fun tearDown() {&#10;        Dispatchers.resetMain()&#10;    }&#10;&#10;    @Test&#10;    fun productDetailViewModel_LoadProductSuccess_UpdatesUiStateToSuccess() = runTest {&#10;        val repository = mockk&lt;ProductRepository&gt;()&#10;        val detail = ProductDetail(&#10;            id = &quot;id&quot;,&#10;            title = &quot;Product&quot;,&#10;            categoryId = &quot;cat&quot;,&#10;            price = 100.0,&#10;            basePrice = 100.0,&#10;            originalPrice = null,&#10;            currencyId = &quot;BRL&quot;,&#10;            thumbnail = &quot;url&quot;,&#10;            pictures = emptyList(),&#10;            attributes = emptyList(),&#10;            shipping = mockk(),&#10;            warranty = null&#10;        )&#10;        val description = ProductDescription(&#10;            text = &quot;Description of the product&quot;,&#10;            plainText = &quot;Plain description&quot;&#10;        )&#10;        val category = Category(&#10;            id = &quot;cat&quot;,&#10;            name = &quot;Category Name&quot;,&#10;            picture = &quot;category_picture_url&quot;,&#10;            pathFromRoot = listOf(),&#10;        )&#10;&#10;        coEvery { repository.getProductDetail(&quot;id&quot;) } returns Result.Success(detail)&#10;        coEvery { repository.getProductDescription(&quot;id&quot;) } returns Result.Success(description)&#10;        coEvery { repository.getProductCategory(&quot;cat&quot;) } returns Result.Success(category)&#10;&#10;        val viewModel = ProductDetailViewModel(repository)&#10;        viewModel.loadProduct(&quot;id&quot;, &quot;cat&quot;)&#10;        advanceUntilIdle()&#10;&#10;        assertTrue(viewModel.uiState.value is ProductDetailUiState.Success)&#10;    }&#10;&#10;    @Test&#10;    fun productDetailViewModel_LoadProductError_UpdatesUiStateToError() = runTest {&#10;        val repository = mockk&lt;ProductRepository&gt;()&#10;        coEvery { repository.getProductDetail(&quot;id&quot;) } returns Result.Error(Exception(&quot;Not found&quot;))&#10;&#10;        val viewModel = ProductDetailViewModel(repository)&#10;        viewModel.loadProduct(&quot;id&quot;, &quot;cat&quot;)&#10;        advanceUntilIdle()&#10;&#10;        assertTrue(viewModel.uiState.value is ProductDetailUiState.Error)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>